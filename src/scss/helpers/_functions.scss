// =========================================================================
// Functions
// =========================================================================

// =========================================================================
// PX - REM
// =========================================================================

/*
    When using this function:
    Do : @include rem(margin-bottom, 2rem);
    Don't : @include rem(margin-bottom, 0rem);
    Don't cause unnessasary conversions as this is bad practice.
    It will also break future builds
*/

@function parseInt($n) {
	@return $n / ($n * 0 + 1);
}

@mixin rem($property, $values) {
	$px : ();
	$rem: ();

	@each $value in $values {

		@if $value == 0 or $value == auto {
			$px : append($px , $value);
			$rem: append($rem, $value);
		}

		@else {
			$unit: unit($value);
			$val: parseInt($value);

			@if $unit == 'px' {
				$px : append($px,  $value);
				$rem: append($rem, ($val / 10 + rem));
			}

			@if $unit == 'rem' {
				$px : append($px,  ($val * 10 + px));
				$rem: append($rem, $value);
			}
		}
	}

	@if $px == $rem {
		#{$property}: $px;
	} @else {
		#{$property}: $px;
		#{$property}: $rem;
	}
}

/*
 * a small mixin for easy use of rem with px as fallback
 * usage: @include x-rem(font-size, 14px)
 * usage: @include x-rem(marign, 0 12px 2 1.2)
 * usage: @include x-rem(padding, 1.5 24px)
 *
 */
@mixin x-rem($property, $values) {
  // Create a couple of empty lists as output buffers.
  $base-font-size: 16px; // should be consistent with your html/body font-size
  $px-values: ();
  $rem-values: ();

  // Loop through the $values list
  @each $value in $values {
    // For each property value, if it's in rem or px, derive both rem and
    // px values for it and add those to the end of the appropriate buffer.
    // Ensure all pixel values are rounded to the nearest pixel.
    @if $value == 0 or $value == 0px {
      // 0 -- use it without a unit
      $px-values: join($px-values, 0);
      $rem-values: join($rem-values, 0);
    } @else if type-of($value) == number and not unitless($value) and (unit($value) == px) {
      // px value given - calculate rem value from base-font-size
      $new-rem-value: $value / $base-font-size;
      $px-values: join($px-values, round($value));
      $rem-values: join($rem-values, #{$new-rem-value}rem);
    } @else {
      // unitless value - use those directly as rem and calculate the px-fallback
      $px-values: join($px-values, round($value * $base-font-size));
      $rem-values: join($rem-values, #{$value}rem);
    }
  }

  // output the converted rules
  #{$property}: $px-values;
  #{$property}: $rem-values;
}

// =========================================================================
// Grid
// =========================================================================

/*
    Change the column and gutter values to reflect the grid that is being used.
*/

$column-width: 80;
$gutter-width: 30;
$columns: 12;

@function gridsystem-width($columns:$columns) {
    @return ($column-width * $columns) + ($gutter-width * $columns);
}

$total-width: gridsystem-width($columns);

$min-width: 999999;
$correction: 0.5 / $min-width * 100;

@mixin column($x,$columns:$columns) {
    float: left;
    width: $total-width*(((($gutter-width+$column-width)*$x)-$gutter-width) / gridsystem-width($columns));
    margin-left: $total-width*(($gutter-width*.5)/gridsystem-width($columns));
    margin-right: $total-width*(($gutter-width*.5)/gridsystem-width($columns));
}
@mixin push($offset:1) {
    margin-left: $total-width*((($gutter-width+$column-width)*$offset) / gridsystem-width($columns)) + $total-width*(($gutter-width*.5)/gridsystem-width($columns));
}
@mixin pull($offset:1) {
    margin-right: $total-width*((($gutter-width+$column-width)*$offset) / gridsystem-width($columns)) + $total-width*(($gutter-width*.5)/gridsystem-width($columns));
}

$total-width: 100%;
